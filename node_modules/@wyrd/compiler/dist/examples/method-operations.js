"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var program = "# Define Using Arrow\ndef Num.add(x: Num): Num => this + x\n\n# Define Using Block\ndef Num.subtract(x: Num): Num => this - x\n\n# Invocation via 'Value'\n123.add(456)\n\n# Invocation via 'Type', should also specify main parameter as first parameter\nNum.subtract(456, 123)\n\n\n# Method Overloading - Define with different input pattern\ndef Num.add(x: Num, y: Num): Num => this + x + y\ndef Num.add(x: Num, y: Num, z: Num): Num => this + x + y + z\n\n# Invoking overloaded method result in different kind of compilation\n123.add(456, 789)\n123.add(456, 789, 666)\n\n# We can also use the invocation via Type way\nNum.add(123, 456, 789)\nNum.add(123, 456, 789, 666)\n\n\n# Method Overriding - Whenever a typical method patten is declared, you need\n# to explicitly address with 'override' keyword in order to override original declaration\noverride def Num.add(x: Num, y: Num): Num => this + x + y + 1\n\n123.add(456, 789) # will now invoke the overrided version of the method\n\noverride def Num.add(x: Num, y: Num): Num => this + x + y + 2\n\n123.add(456, 789) # will yet again invoke the overrided version of the method\n";
exports.program = program;
var compiled = "function Num_add(_this, x) {\n  return _this + x;\n}\n\nfunction Num_subtract(_this, x) {\n  return _this - x;\n}\n\nNum_add(123, 456);\nNum_subtract(456, 123);\nfunction Num_add_1(_this, x, y) {\n  return _this + x + y;\n}\n\nfunction Num_add_2(_this, x, y, z) {\n  return _this + x + y + z;\n}\n\nNum_add_1(123, 456, 789);\nNum_add_2(123, 456, 789, 666);\nNum_add_1(123, 456, 789);\nNum_add_2(123, 456, 789, 666);\nfunction Num_add_1$1(_this, x, y) {\n  return _this + x + y + 1;\n}\n\nNum_add_1$1(123, 456, 789);\nfunction Num_add_1$2(_this, x, y) {\n  return _this + x + y + 2;\n}\n\nNum_add_1$2(123, 456, 789);\n";
exports.compiled = compiled;
