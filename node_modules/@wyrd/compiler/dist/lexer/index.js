"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var tokenMap_1 = __importDefault(require("./tokenMap"));
var constants_1 = require("./constants");
var error_1 = require("../parser/error");
function LexerError(msg) {
    throw new Error("Lexer Error: " + msg);
}
function lex(code) {
    var result = [];
    var index = 0;
    var currentChar = code[index];
    var peekChar = code[index + 1];
    function nextChar(skip) {
        if (skip === void 0) { skip = 1; }
        index += skip;
        currentChar = code[index];
        peekChar = code[index + 1];
    }
    while (index < code.length) {
        if (constants_1.regex.whitespace.test(currentChar)) {
            if (currentChar === '\n')
                result.push({ type: 'newline', value: '\n' });
            nextChar();
            continue;
        }
        /* String Lexing */
        if (currentChar === '"') {
            nextChar();
            var parsedString = '';
            while (currentChar !== '"') {
                parsedString += currentChar;
                nextChar();
            }
            nextChar();
            result.push({ type: 'string', value: parsedString });
            continue;
        }
        /* Comment Lexing */
        if (currentChar === '#') {
            nextChar();
            var cond = function () { return currentChar !== '\n'; };
            var isMultilineComment = false;
            if (currentChar === '#') {
                nextChar();
                isMultilineComment = true;
                cond = function () { return !(currentChar === '#' && peekChar === '#'); };
            }
            // let parsedComment = '';
            while (cond()) {
                // parsedComment += currentChar;
                nextChar();
            }
            if (isMultilineComment)
                nextChar(2); // Skip the double '#' token
            // TODO: Add an compiler option for retain comment, which is `skipComment: false`
            // result.push({ type: 'comment', value: parsedComment });
            continue;
        }
        /* Library Tag Lexing */
        if (currentChar === '@' && (peekChar !== ' ' && peekChar !== '\n')) {
            var tag = '';
            nextChar();
            while (/[a-z|\-]+/.test(currentChar)) {
                tag += currentChar;
                nextChar();
            }
            if (!constants_1.libTags.has(tag))
                error_1.ParserError("LexerError: Unidentified library tag `@" + tag + "`");
            result.push({ type: 'lib-tag', value: tag });
            continue;
        }
        if (tokenMap_1.default.has(currentChar)) {
            if (currentChar === '-' && peekChar === '>') {
                result.push(tokenMap_1.default.get('->'));
                nextChar(2);
                continue;
            }
            if (currentChar === '=') {
                if (peekChar === '>') {
                    result.push(tokenMap_1.default.get('=>'));
                    nextChar(2);
                    continue;
                }
                if (peekChar === '=') {
                    result.push(tokenMap_1.default.get('=='));
                    nextChar(2);
                    continue;
                }
            }
            if (currentChar === '>' && peekChar === '=') {
                result.push(tokenMap_1.default.get('>='));
                nextChar(2);
                continue;
            }
            if (currentChar === '<' && peekChar === '=') {
                result.push(tokenMap_1.default.get('<='));
                nextChar(2);
                continue;
            }
            if (currentChar === '!' && peekChar === '=') {
                result.push(tokenMap_1.default.get('!='));
                nextChar(2);
                continue;
            }
            if (currentChar === '|' && peekChar === '>') {
                result.push(tokenMap_1.default.get('|>'));
                nextChar(2);
                continue;
            }
            result.push(tokenMap_1.default.get(currentChar));
            nextChar();
            continue;
        }
        if (constants_1.regex.number.test(currentChar)) {
            var parsedNumber = '';
            do {
                parsedNumber += currentChar;
                nextChar();
            } while (constants_1.regex.number.test(currentChar) && index < code.length);
            result.push({ type: 'number', value: parsedNumber });
            continue;
        }
        if (constants_1.regex.letter.test(currentChar)) {
            var parsedName = '';
            do {
                parsedName += currentChar;
                nextChar();
            } while (constants_1.regex.naming.test(currentChar) && currentChar !== undefined);
            if (constants_1.keywords.has(parsedName)) {
                result.push({ type: 'keyword', value: parsedName });
                continue;
            }
            if (constants_1.keyvalues.has(parsedName)) {
                if (parsedName === 'True' || parsedName === 'False') {
                    result.push({ type: 'boolean', value: parsedName });
                    continue;
                }
                if (parsedName === 'Null') {
                    result.push({ type: 'null', value: parsedName });
                    continue;
                }
                LexerError("Unhandled key-value: `" + parsedName + "`");
            }
            if (constants_1.builtinTypes.has(parsedName)) {
                result.push({ type: 'builtin-type', value: parsedName });
                continue;
            }
            result.push({ type: 'ident', value: parsedName });
            continue;
        }
        LexerError("Unhandled Character: `" + currentChar + "`");
    }
    return result;
}
exports.lex = lex;
