import { Scope, DataType as DT } from './parser/utils';
export declare type Token = {
    type: string;
    value: string;
};
export declare const enum Precedence {
    High = 1,
    Equal = 0,
    Low = -1
}
export declare const enum Operator {
    Plus = "+",
    Dash = "-",
    Asterisk = "*",
    Slash = "/",
    Percent = "%",
    Gt = ">",
    GtEq = ">=",
    Lt = "<",
    LtEq = "<=",
    EqEq = "==",
    BangEq = "!="
}
export interface Operand {
    left: DT;
    right: DT;
    return: DT;
}
export declare type CompilerOptions = {
    minify?: boolean;
    program?: string;
    entry?: string;
    dir?: string;
    mainFileOnly?: boolean;
    showAST?: boolean;
    defaultAST?: AST;
    scopeMiddleware?: (scope: Scope) => Scope;
};
export declare type CompileResult = {
    result: string;
    ast: AST;
};
export declare type GenericPlacholder = {
    generic: string;
    placeholder: string;
};
export declare type AST = Array<Expr>;
interface Expression {
    type: string;
    return: DT;
}
export declare type Expr = EmptyExpr | VoidExpr | BinaryOpExpr | NotExpr | OrExpr | AndExpr | AssignmentExpr | VarDeclaration | VarAssignmentExpr | PrioritizedExpr | ConditionalExpr | FunctionDeclaration | FunctionInvokeExpr | MethodDeclaration | MethodInvokeExpr | DoBlockExpr | IdentLiteral | NumberLiteral | StringLiteral | BooleanLiteral | NullLiteral | ListLiteral | TypeLiteral | ThisLiteral | RecordLiteral | RecordReferenceExpr;
export declare type ExpressionParsingFunction = (prevExpr?: Expr, meta?: any) => Expr;
export interface EmptyExpr extends Expression {
    type: 'EmptyExpr';
    return: typeof DT.Invalid;
}
export interface VoidExpr extends Expression {
    type: 'VoidExpr';
    return: typeof DT.Void;
}
export interface NumberLiteral extends Expression {
    type: 'NumberLiteral';
    value: string;
    return: typeof DT.Num;
}
export interface StringLiteral extends Expression {
    type: 'StringLiteral';
    value: string;
    return: typeof DT.Str;
}
export interface BooleanLiteral extends Expression {
    type: 'BooleanLiteral';
    value: 'True' | 'False';
    return: typeof DT.Bool;
}
export interface NullLiteral extends Expression {
    type: 'NullLiteral';
    value: 'Null';
    return: typeof DT.Null;
}
export interface ListLiteral extends Expression {
    type: 'ListLiteral';
    values: Array<Expr>;
    elementType: DT;
}
export interface IdentLiteral extends Expression {
    type: 'IdentLiteral';
    value: string;
}
export interface TypeLiteral extends Expression {
    type: 'TypeLiteral';
    value: string;
    typeObject: DT;
    return: typeof DT.Void;
}
export interface ThisLiteral extends Expression {
    type: 'ThisLiteral';
    return: DT;
}
export interface VarDeclaration extends Expression {
    type: 'VarDeclaration';
    expr1: IdentLiteral;
    expr2: Expr;
    return: typeof DT.Void;
}
export interface VarAssignmentExpr extends Expression {
    type: 'VarAssignmentExpr';
    expr1: IdentLiteral;
    expr2: Expr;
    return: typeof DT.Void;
}
export interface AssignmentExpr extends Expression {
    type: 'AssignmentExpr';
    expr1: IdentLiteral;
    expr2: Expr;
    return: typeof DT.Void;
}
export interface PrioritizedExpr extends Expression {
    type: 'PrioritizedExpr';
    expr: Expr;
}
export interface ConditionalExpr extends Expression {
    type: 'ConditionalExpr';
    condition: Expr;
    expr1: Expr;
    expr2: Expr;
}
export interface BinaryOpExpr extends Expression {
    type: 'BinaryOpExpr';
    operator: Operator;
    expr1: Expr;
    expr2: Expr;
}
export interface NotExpr extends Expression {
    type: 'NotExpr';
    expr: Expr;
    return: typeof DT.Bool;
}
export interface OrExpr extends Expression {
    type: 'OrExpr';
    expr1: Expr;
    expr2: Expr;
    return: typeof DT.Bool;
}
export interface AndExpr extends Expression {
    type: 'AndExpr';
    expr1: Expr;
    expr2: Expr;
    return: typeof DT.Bool;
}
export declare type Argument = {
    ident: string;
    type: DT;
};
export interface FunctionDeclaration extends Expression {
    type: 'FunctionDeclaration';
    name: string;
    arguments: Array<Argument>;
    outputType: DT;
    body: Array<Expr>;
    return: typeof DT.Void;
}
export interface FunctionInvokeExpr extends Expression {
    type: 'FunctionInvokeExpr';
    name: string;
    params: Array<Expr>;
}
export interface MethodDeclaration extends Expression {
    type: 'MethodDeclaration';
    receiverType: DT;
    name: string;
    arguments: Array<Argument>;
    outputType: DT;
    body: Array<Expr>;
    return: typeof DT.Void;
}
export interface MethodInvokeExpr extends Expression {
    type: 'MethodInvokeExpr';
    name: string;
    receiver: Expr;
    isNotBuiltin?: boolean;
    params: Array<Expr>;
}
export declare type RecordProperty = {
    name: string;
    type: DT;
};
export declare type RecordPropertyValue = RecordProperty & {
    value: Expr;
};
export interface RecordLiteral extends Expression {
    type: 'RecordLiteral';
    properties: Array<RecordPropertyValue>;
}
export interface RecordReferenceExpr extends Expression {
    type: 'RecordReferenceExpr';
    recordExpr: Expr;
    property: string;
}
export interface DoBlockExpr extends Expression {
    type: 'DoBlockExpr';
    body: Array<Expr>;
}
export {};
