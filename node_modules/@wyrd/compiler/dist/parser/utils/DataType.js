"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var error_1 = require("../error");
var DataType = /** @class */ (function () {
    function DataType(type, nullable) {
        if (nullable === void 0) { nullable = false; }
        this.type = type;
        this.nullable = nullable;
        this.typeParams = new Map();
        this.typeParameterMap = {};
        this.typeParameters = [];
        this.typeParameterPlaceholderMap = {};
        this.isGeneric = false;
    }
    DataType.isList = function (t) {
        return t.type === 'List';
    };
    DataType.ListOf = function (t, nullable) {
        if (nullable === void 0) { nullable = false; }
        var dt = new DataType('List', nullable);
        dt.newTypeParameter('element', t);
        return dt;
    };
    DataType.isInvalid = function (t) {
        return t.isEqualTo(DataType.Invalid);
    };
    DataType.isVoid = function (t) {
        return t.isEqualTo(DataType.Void);
    };
    DataType.Generic = function (name, nullable) {
        if (nullable === void 0) { nullable = false; }
        var dt = new DataType(name, nullable);
        dt.isGeneric = true;
        return dt;
    };
    DataType.GenericList = function () {
        return DataType.ListOf(DataType.Generic('element'));
    };
    DataType.prototype.toString = function () {
        var typeParams = this.typeParameters;
        var typeParamsString = '';
        if (typeParams.length !== 0)
            typeParamsString = "<" + typeParams.map(function (t) { return t.type; }) + ">";
        return "" + (this.nullable ? 'maybe ' : '') + this.type + typeParamsString;
    };
    // For instance, Num is assignable to Maybe Num (or Num?)
    DataType.prototype.isAssignableTo = function (otherDT) {
        if (this.type !== otherDT.type)
            return (this.type === 'Null' && otherDT.nullable);
        if (this.type === 'Null' && otherDT.type === 'Null')
            return true;
        return !(!otherDT.nullable && (this.nullable || this.type === 'Null'));
    };
    DataType.prototype.isNotAssignableTo = function (otherDT) {
        return !this.isAssignableTo(otherDT);
    };
    DataType.prototype.isEqualTo = function (otherDT) {
        return this.toString() === otherDT.toString();
    };
    DataType.prototype.isNotEqualTo = function (otherDT) {
        return this.toString() !== otherDT.toString();
    };
    DataType.prototype.toNullable = function () {
        if (this.hasTypeParameters()) {
            var result_1 = new DataType(this.type, true);
            this.typeParameters.forEach(function (tp) {
                result_1.newTypeParameter(tp.name, tp.type);
            });
            return result_1;
        }
        return new DataType(this.type, true);
    };
    DataType.prototype.newTypeParameter = function (paramName, dt) {
        if (dt === void 0) { dt = DataType.Unknown; }
        if (this.typeParams.has(paramName))
            error_1.ParserError("Type parameter `" + paramName + "` has already declared in data type `" + this.type + "`");
        var tp = {
            name: paramName,
            type: dt,
            order: this.typeParams.size + 1
        };
        this.typeParams.set(paramName, tp);
        this.typeParameterMap[paramName] = dt;
        this.typeParameters.push(tp);
    };
    DataType.prototype.getTypeParameter = function (paramName) {
        if (this.typeParams.has(paramName))
            return this.typeParams.get(paramName);
        error_1.ParserError("Type `" + this.type + "` has no type parameter of name `" + paramName + "`");
    };
    DataType.prototype.hasTypeParameters = function () {
        return this.typeParams.size !== 0;
    };
    DataType.prototype.applyTypeParametersFrom = function (otherDT) {
        var mapping = otherDT.typeParameterMap;
        var dt = new DataType(this.type);
        this.typeParameters.forEach(function (tp) {
            dt.newTypeParameter(tp.name, tp.type.isGeneric ? mapping[tp.name] : tp.type);
        });
        return dt;
    };
    DataType.Num = new DataType('Num');
    DataType.Str = new DataType('Str');
    DataType.Bool = new DataType('Bool');
    DataType.Null = new DataType('Null');
    DataType.Void = new DataType('Void');
    DataType.Invalid = new DataType('Invalid');
    DataType.Unknown = new DataType('Unknown');
    /* Maybe-types or Nullable-types may contain Null values */
    DataType.Maybe = {
        Num: new DataType('Num', true),
        Str: new DataType('Str', true),
        Bool: new DataType('Bool', true),
    };
    return DataType;
}());
exports.default = DataType;
