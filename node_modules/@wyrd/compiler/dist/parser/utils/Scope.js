"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require(".");
var error_1 = require("../error");
var Scope = /** @class */ (function () {
    function Scope() {
        this.parent = null;
        this.children = new Map();
        this.variables = new Map();
        this.functions = new Map();
        this.methods = new Map();
        this.operators = new Map();
        this.records = new Map();
        this.declaredGenerics = new Map();
        this.genericPlacholders = new Map();
    }
    Scope.prototype.createChildScope = function (name) {
        var scope = new Scope();
        this.children.set(name, scope);
        scope.parent = this;
        return scope;
    };
    Scope.prototype.canBeNamedAs = function (name) {
        return (this.hasVariable(name) ||
            this.hasFunction(name) ||
            this.hasRecord(name));
    };
    Scope.prototype.hasVariable = function (name) {
        return this.variables.has(name) || (this.parent ? this.parent.hasVariable(name) : false);
    };
    Scope.prototype.getVariable = function (name) {
        var varInfo = this.variables.get(name);
        if (varInfo === undefined) {
            if (this.parent === null)
                error_1.ParserError("Variable or Constant `" + name + "` isn't found throughout the scope chain");
            return this.parent.getVariable(name);
        }
        return varInfo;
    };
    Scope.prototype.createConstant = function (name, type) {
        if (type === void 0) { type = _1.DataType.Unknown; }
        if (this.variables.has(name)) {
            var varInfo = this.variables.get(name);
            error_1.ParserError((varInfo.isConst ? 'Constant' : 'Variable') + " `" + varInfo.name + "` is already declared with type `" + varInfo.type + "`");
        }
        var variable = new _1.ScopeVariable(name, type);
        this.variables.set(name, variable);
        return variable;
    };
    Scope.prototype.createMutableVariable = function (name, type) {
        if (type === void 0) { type = _1.DataType.Unknown; }
        if (this.variables.has(name)) {
            var varInfo = this.variables.get(name);
            error_1.ParserError((varInfo.isConst ? 'Constant' : 'Variable') + " `" + varInfo.name + "` is already declared with type `" + varInfo.type + "`");
        }
        var variable = new _1.ScopeVariable(name, type, false);
        this.variables.set(name, variable);
        return variable;
    };
    Scope.prototype.hasFunction = function (name) {
        return this.functions.has(name) || (this.parent ? this.parent.hasFunction(name) : false);
    };
    Scope.prototype.getFunction = function (name) {
        var functionObj = this.functions.get(name);
        if (functionObj === undefined) {
            if (this.parent === null)
                error_1.ParserError("Function `" + name + "` isn't declared throughout scope chain");
            return this.parent.getFunction(name);
        }
        return functionObj;
    };
    Scope.prototype.getFunctionPattern = function (name, parameter) {
        var functionObj = this.getFunction(name);
        var result = functionObj.getPatternInfo(parameter);
        if (result === undefined)
            error_1.ParserError("Function `" + name + "` with input parameter `" + parameter + "` isn't declared throughout scope chain");
        return result;
    };
    Scope.prototype.createFunction = function (name) {
        if (this.functions.has(name))
            error_1.ParserError("Function object `" + name + "` has already been created in current scope");
        var functionObj = new _1.ScopeFunctionObject(name);
        this.functions.set(name, functionObj);
        return functionObj;
    };
    Scope.prototype.hasMethod = function (receiver, name) {
        if (this.methods.has(receiver.type)) {
            var methodType = this.methods.get(receiver.type);
            if (methodType.methods.has(name))
                return true;
        }
        return this.parent ? this.parent.hasMethod(receiver, name) : false;
    };
    Scope.prototype.getMethod = function (receiver, name) {
        var methodType = this.methods.get(receiver.type);
        if (methodType === undefined) {
            if (this.parent === null)
                error_1.ParserError("Method `" + receiver.type + "." + name + "` isn't declared throughout scope chain");
            return this.parent.getMethod(receiver, name);
        }
        var methodObj = methodType.methods.get(name);
        if (methodObj === undefined) {
            if (this.parent === null)
                error_1.ParserError("Method `" + receiver.type + "." + name + "` isn't declared throughout scope chain");
            return this.parent.getMethod(receiver, name);
        }
        return methodObj;
    };
    Scope.prototype.getMethodPattern = function (receiver, name, parameter) {
        var methodObj = this.getMethod(receiver, name);
        return methodObj.getPatternInfo(receiver, parameter);
    };
    Scope.prototype.createMethod = function (receiver, name) {
        var methodType;
        if (this.methods.has(receiver.type)) {
            methodType = this.methods.get(receiver.type);
        }
        else {
            // TODO: Support List[T] Type
            methodType = new _1.ScopeMethodType(receiver.type);
            this.methods.set(receiver.type, methodType);
        }
        return methodType.createMethod(name);
    };
    Scope.prototype.hasOperator = function (name) {
        return this.operators.has(name) || (this.parent ? this.parent.hasOperator(name) : false);
    };
    Scope.prototype.getOperator = function (op) {
        var operatorObj = this.operators.get(op);
        if (operatorObj === undefined) {
            if (this.parent === null)
                error_1.ParserError("Operator `" + op + "` isn't declared throughout scope chain");
            return this.parent.getOperator(op);
        }
        return operatorObj;
    };
    Scope.prototype.getOperatorPattern = function (op, opType1, opType2) {
        var operatorObj = this.getOperator(op);
        return operatorObj.getPatternInfo(opType1, opType2);
    };
    Scope.prototype.createOperator = function (op) {
        var operatorObj = new _1.ScopeOperatorObject(op);
        this.operators.set(op, operatorObj);
        return operatorObj;
    };
    Scope.prototype.hasRecord = function (name) {
        return this.records.has(name) || (this.parent ? this.parent.hasRecord(name) : false);
    };
    Scope.prototype.getRecord = function (name) {
        var result = this.records.get(name);
        if (result === undefined) {
            if (this.parent === null)
                error_1.ParserError("Record `" + name + "` isn't declared throughout scope chain");
            return this.parent.getRecord(name);
        }
        return result;
    };
    Scope.prototype.createRecord = function (name) {
        if (this.records.has(name))
            error_1.ParserError("Record `" + name + "` is already declared in current scope");
        var r = new _1.ScopeRecord(name);
        this.records.set(name, r);
        return r;
    };
    Scope.prototype.declareGenericType = function (name) {
        var gt = new _1.GenericType(name);
        this.declaredGenerics.set(name, gt);
        return gt;
    };
    Scope.prototype.hasGenericType = function (name) {
        return this.declaredGenerics.has(name) || (this.parent ? this.parent.hasGenericType(name) : false);
    };
    Scope.prototype.getGenericType = function (name) {
        var result = this.declaredGenerics.get(name);
        if (result === undefined)
            if (this.parent !== null)
                return this.parent.getGenericType(name);
            else
                error_1.ParserError("`" + name + "` isn't found as generic type throughout scope");
        return result;
    };
    Scope.prototype.createGenericPlaceholder = function (placeholder, name) {
        var gp = { placeholder: placeholder, generic: name };
        this.genericPlacholders.set(placeholder, gp);
        return gp;
    };
    Scope.prototype.hasGenericPlaceholder = function (placeholder) {
        return this.genericPlacholders.has(placeholder) || (this.parent !== null ? this.parent.hasGenericPlaceholder(placeholder) : false);
    };
    Scope.prototype.getGenericPlaceholder = function (placeholder) {
        return this.genericPlacholders.get(placeholder);
    };
    Scope.prototype.getGenericTypeFromPlaceholder = function (placeholder) {
        var gp = this.getGenericPlaceholder(placeholder);
        return _1.DataType.Generic(gp.generic);
    };
    return Scope;
}());
exports.default = Scope;
