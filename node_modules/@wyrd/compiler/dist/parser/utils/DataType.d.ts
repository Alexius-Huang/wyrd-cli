declare type TypeParameter = {
    name: string;
    type: DataType;
    order: number;
};
export default class DataType {
    type: string;
    readonly nullable: boolean;
    static isList(t: DataType): boolean;
    static ListOf(t: DataType, nullable?: boolean): DataType;
    static isInvalid(t: DataType): boolean;
    static isVoid(t: DataType): boolean;
    static Generic(name: string, nullable?: boolean): DataType;
    static GenericList(): DataType;
    static Num: DataType;
    static Str: DataType;
    static Bool: DataType;
    static Null: DataType;
    static Void: DataType;
    static Invalid: DataType;
    static Unknown: DataType;
    static Maybe: {
        Num: DataType;
        Str: DataType;
        Bool: DataType;
    };
    private typeParams;
    readonly typeParameterMap: {
        [key: string]: DataType;
    };
    readonly typeParameters: Array<TypeParameter>;
    readonly typeParameterPlaceholderMap: {
        [key: string]: string;
    };
    isGeneric: boolean;
    constructor(type: string, nullable?: boolean);
    toString(): string;
    isAssignableTo(otherDT: DataType): boolean;
    isNotAssignableTo(otherDT: DataType): boolean;
    isEqualTo(otherDT: DataType): boolean;
    isNotEqualTo(otherDT: DataType): boolean;
    toNullable(): DataType;
    newTypeParameter(paramName: string, dt?: DataType): void;
    getTypeParameter(paramName: string): TypeParameter;
    hasTypeParameters(): boolean;
    applyTypeParametersFrom(otherDT: DataType): DataType;
}
export {};
