"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
var parameters_1 = require("./function/parameters");
var error_1 = require("./error");
var type_literal_1 = require("./type-literal");
function parsePipeOperation(tt, parseExpr, scope, prevExpr) {
    var receiver = prevExpr;
    tt.next(); // skip `|>`
    if (tt.is('ident')) {
        if (scope.hasFunction(tt.value)) {
            var funcName = tt.value;
            tt.next(); // Skip `ident`: function name
            if (tt.isNot('lparen'))
                error_1.ParserError("Expect function invocation's parameter to be nested by parentheses, instead got token of type: `" + tt.type + "`");
            tt.next();
            var params = parameters_1.parseParameters(tt, parseExpr, scope);
            params.unshift(receiver);
            var typeParams = utils_1.Parameter.from(params.map(function (p) { return p.return; }));
            var pattern = scope.getFunctionPattern(funcName, typeParams);
            return {
                type: 'FunctionInvokeExpr',
                name: pattern.name,
                return: pattern.returnDataType,
                params: params,
            };
        }
    }
    /* Method invocation by type */
    else if (tt.is('builtin-type')) {
        var typeLiteral = type_literal_1.parseTypeLiteral(tt, parseExpr, scope);
        var receiverType = typeLiteral.typeObject;
        if (receiverType.isNotEqualTo(receiver.return))
            error_1.ParserError("Expect receiver in pipe-operation to have type `" + receiverType + "`, instead got type `" + receiver.return + "`");
        tt.next(); // Skip `type`
        if (tt.isNot('dot'))
            error_1.ParserError("Expect invoking method in pipe-operation token of type `dot`, instead got: `" + tt.type + "`");
        tt.next(); // Skip `dot`
        if (tt.isNot('ident'))
            error_1.ParserError("Expect invoking method in pipe-operation with the name of the method, instead got token of type: `" + tt.type + "`");
        var tokMethodName = tt.value;
        var methodInvokeName = receiverType + "." + tokMethodName;
        if (!scope.hasMethod(receiverType, tokMethodName))
            error_1.ParserError("Invoking an undeclared method `" + methodInvokeName + "` during pipe operation");
        tt.next(); // Skip `ident`
        if (tt.isNot('lparen'))
            error_1.ParserError("Expect method invocation's parameter to be nested by parentheses, instead got token of type: `" + tt.type + "`");
        tt.next(); // Skip `lparen`
        var params = parameters_1.parseParameters(tt, parseExpr, scope);
        var typeParams = utils_1.Parameter.from(params.map(function (p) { return p.return; }));
        var methodPattern = scope.getMethodPattern(receiverType, tokMethodName, typeParams);
        if (methodPattern === undefined)
            error_1.ParserError("Method for `" + methodInvokeName + "` with input pattern `" + typeParams + "` doesn't exist");
        var result = {
            type: 'MethodInvokeExpr',
            isNotBuiltin: methodPattern.isNotBuiltin,
            receiver: receiver,
            params: params,
            name: methodPattern.isNotBuiltin ? receiverType.type + "_" + methodPattern.name : methodPattern.name,
            return: utils_1.DataType.Unknown,
        };
        var returnType = methodPattern.returnDataType;
        if (returnType.hasTypeParameters()) {
            result.return = returnType.applyTypeParametersFrom(receiverType);
        }
        else if (returnType.isGeneric) {
            result.return = receiverType.typeParameterMap[returnType.type];
        }
        else {
            result.return = returnType;
        }
        return result;
    }
    if (tt.is('ident'))
        error_1.ParserError("Unknown identifier `" + tt.value + "` is used");
    error_1.ParserError("Pipe operation do not accept token of type `" + tt.type + "`");
}
exports.parsePipeOperation = parsePipeOperation;
