"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("../utils");
var error_1 = require("../error");
var type_literal_1 = require("../type-literal");
var parameters_1 = require("../function/parameters");
function parseLibDirectMethodMapping(tt, parseExpr, scope) {
    tt.next(); // Skip `@direct-method-mapping`
    if (tt.isNot('newline'))
        error_1.ParserError("Expect token after @direct-method-mapping to be `newline`, instead got `" + tt.type + "`");
    tt.next(); // Skip `newline`
    while (tt.isNot('lib-tag') && tt.valueIsNot('end')) {
        if (tt.isOneOf('builtin-type', 'ident'))
            configureDirectMethodMapping(tt, parseExpr, scope);
        tt.next();
    }
    return scope;
}
exports.parseLibDirectMethodMapping = parseLibDirectMethodMapping;
function configureDirectMethodMapping(tt, parseExpr, scope) {
    if (tt.isNot('builtin-type') && !scope.hasGenericType(tt.value))
        error_1.ParserError("Expect direct method mapping to declare the type and method name first, instead got token of type `" + tt.type + "`");
    var typeLiteral = type_literal_1.parseTypeLiteral(tt, parseExpr, scope);
    var receiverType = typeLiteral.typeObject;
    var childScope = scope.createChildScope('dmm-declaration');
    if (receiverType.hasTypeParameters()) {
        var tps = receiverType.typeParameters;
        for (var i = 0; i < tps.length; i += 1) {
            var tp = tps[i];
            childScope.createGenericPlaceholder(tp.type.type, tp.name);
            tp.type.type = tp.name;
        }
    }
    tt.next(); // Skip 'builtin-type'
    if (tt.isNot('dot'))
        error_1.ParserError("Expect direct method mapping's method name and receiver to be delimited by `dot`, instead got token of type `" + tt.type + "`");
    tt.next(); // Skip `dot`
    if (tt.isNot('ident'))
        error_1.ParserError("Expect direct method mapping to declare with method name, instead got token of type `" + tt.type + "`");
    var methodName = tt.value;
    tt.next(); // Skip `ident`
    var mappedMethodParameter = utils_1.Parameter.Void();
    var mappedMethodReturnType = receiverType;
    var mappedMethod = methodName;
    var methodObj;
    if (scope.hasMethod(receiverType, methodName))
        methodObj = scope.getMethod(receiverType, methodName);
    else
        methodObj = scope.createMethod(receiverType, methodName);
    var _loop_1 = function () {
        if (tt.isNot('lib-tag'))
            error_1.ParserError("Expect direct method mapping to parse with `lib-tag`, instead got token of type `" + tt.type + "`");
        if (tt.valueIs('maps')) {
            tt.next(); // Skip `@maps`
            checkLParenTokenExists('maps', tt);
            var params = parameters_1.parseParameters(tt, parseExpr, childScope);
            checkParameterLength('maps', params, 1);
            checkParameterType('maps', params[0], { type: 'StringLiteral', value: 'any', return: utils_1.DataType.Str });
            tt.next(); // Skip `rparen`
            mappedMethod = params[0].value;
        }
        if (tt.valueIs('params')) {
            tt.next(); // Skip `@maps`
            checkLParenTokenExists('params', tt);
            var params_1 = parameters_1.parseParameters(tt, parseExpr, childScope);
            tt.next(); // Skip `rparen`
            var typeParameters_1 = [];
            params_1.forEach(function (p) {
                if (p.type === 'IdentLiteral' && childScope.hasGenericPlaceholder(p.value)) {
                    typeParameters_1.push(childScope.getGenericTypeFromPlaceholder(p.value));
                }
                else if (p.type === 'TypeLiteral') {
                    typeParameters_1.push(p.typeObject);
                }
                else {
                    error_1.ParserError("Expect library tag `@params` to receive type literals, instead got value of type `" + params_1[0].return + "`");
                }
            });
            mappedMethodParameter = utils_1.Parameter.from(typeParameters_1);
        }
        if (tt.valueIs('returns')) {
            tt.next(); // Skip `@returns`
            checkLParenTokenExists('returns', tt);
            var params = parameters_1.parseParameters(tt, parseExpr, childScope);
            checkParameterLength('returns', params, 1);
            if (params[0].type === 'IdentLiteral' && childScope.hasGenericPlaceholder(params[0].value)) {
                mappedMethodReturnType = childScope.getGenericTypeFromPlaceholder(params[0].value);
            }
            else if (params[0].type === 'TypeLiteral') {
                mappedMethodReturnType = params[0].typeObject;
            }
            else {
                error_1.ParserError("Expect library tag `@returns` to receive `type literal`, instead got value of type `" + params[0].return + "`");
            }
            tt.next(); // Skip `rparen`
        }
    };
    while (tt.isNot('newline')) {
        _loop_1();
    }
    methodObj.createNewPattern(mappedMethodParameter, mappedMethodReturnType, {
        directMapping: mappedMethod,
        isNotBuiltin: false
    });
}
function checkLParenTokenExists(tagName, tt) {
    if (tt.isNot('lparen'))
        error_1.ParserError("Expect parameter of `@" + tagName + "` to surrounded by `lparen`, instead got token of type `" + tt.type + "`");
    tt.next(); // Skip `lparen`
}
function checkParameterLength(tagName, params, length) {
    if (params.length !== length)
        error_1.ParserError("Expect library tag `@" + tagName + "` to receive only " + length + " parameter(s), instead got " + params.length + " parameter(s)");
}
function checkParameterType(tagName, param, expected) {
    if (param.type !== expected.type)
        error_1.ParserError("Expect library tag `@" + tagName + "` to receive `" + expected.return + "`, instead got value of type `" + param.return + "`");
}
