"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
var error_1 = require("./error");
function parseThisLiteral(tt, scope, prevExpr) {
    var result = {
        type: 'ThisLiteral',
        return: utils_1.DataType.Invalid,
    };
    if (scope.hasVariable('this')) {
        result.return = scope.getVariable('this').type;
    }
    else {
        error_1.ParserError('Unhandled using `this` keyword token');
    }
    // TODO: The following code handling binary operation and prioritization is duplicated
    //       with primitive type parsing, find a way to refactor them
    if ((prevExpr === null || prevExpr === void 0 ? void 0 : prevExpr.type) === 'BinaryOpExpr') {
        prevExpr.expr2 = result;
        var operator = prevExpr.operator;
        var opLeft = prevExpr.expr1.return;
        var opRight = result.return;
        var operatorObj = scope.getOperatorPattern(operator, opLeft, opRight);
        if (operatorObj === undefined)
            error_1.ParserError("Invalid operation for operator `" + prevExpr.operator + "` with operands of type `" + opLeft + "` and `" + opRight + "`");
        prevExpr.return = operatorObj.returnDataType;
        return prevExpr;
    }
    if ((prevExpr === null || prevExpr === void 0 ? void 0 : prevExpr.type) === 'PrioritizedExpr') {
        prevExpr.expr = result;
        prevExpr.return = result.return;
    }
    return result;
}
exports.parseThisLiteral = parseThisLiteral;
