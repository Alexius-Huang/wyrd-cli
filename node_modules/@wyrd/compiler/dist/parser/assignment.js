"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
var error_1 = require("./error");
var constants_1 = require("./constants");
function parseAssignmentExpr(tt, parseExpr, scope, prevExpr) {
    tt.next(); // Skip the `eq` token
    if ((prevExpr === null || prevExpr === void 0 ? void 0 : prevExpr.type) === 'IdentLiteral') {
        // Check if variable is constant and redeclared in the same scope
        var varName = prevExpr.value;
        if (scope.hasVariable(varName)) {
            var varInfo_1 = scope.getVariable(varName);
            error_1.ParserErrorIf(varInfo_1.isConst, "Constant `" + varName + "` cannot be reassigned");
            // Mutable Variable Assignment
            var result_1 = {
                type: 'VarAssignmentExpr',
                expr1: prevExpr,
                expr2: constants_1.EmptyExpression,
                return: utils_1.DataType.Void,
            };
            var subAST_1 = [];
            while (tt.isNot('newline')) {
                var expr = parseExpr(undefined, { scope: scope, ast: subAST_1 });
                subAST_1.push(expr);
                if (tt.is('newline') || !tt.hasNext())
                    break;
                tt.next();
            }
            result_1.expr2 = subAST_1.pop();
            var isInvalid_1 = utils_1.DataType.isInvalid(result_1.expr2.return);
            var isVoid_1 = utils_1.DataType.isVoid(result_1.expr2.return);
            error_1.ParserErrorIf(isInvalid_1 || isVoid_1, "Expect variable `" + varName + "` not declared as type 'Invalid' or 'Void'");
            error_1.ParserErrorIf(!result_1.expr2.return.isAssignableTo(varInfo_1.type), "Expect mutable variable `" + varName + "` to assign value of type `" + varInfo_1.type + "`, instead got: `" + result_1.expr2.return + "`");
            return result_1;
        }
        // Constant Declaration
        var result = {
            type: 'AssignmentExpr',
            expr1: prevExpr,
            expr2: constants_1.EmptyExpression,
            return: utils_1.DataType.Void,
        };
        var varInfo = scope.createConstant(varName);
        var subAST = [];
        while (tt.isNot('newline')) {
            var expr = parseExpr(undefined, { scope: scope, ast: subAST });
            subAST.push(expr);
            if (tt.is('newline') || !tt.hasNext())
                break;
            tt.next();
        }
        result.expr2 = subAST.pop();
        var isInvalid = utils_1.DataType.isInvalid(result.expr2.return);
        var isVoid = utils_1.DataType.isVoid(result.expr2.return);
        error_1.ParserErrorIf(isInvalid || isVoid, "Expect variable `" + varName + "` not declared as type 'Invalid' or 'Void'");
        prevExpr.return = result.expr2.return;
        varInfo.type = prevExpr.return;
        return result;
    }
    error_1.ParserError("Unhandled expression of type `" + prevExpr.type + "`");
}
exports.parseAssignmentExpr = parseAssignmentExpr;
