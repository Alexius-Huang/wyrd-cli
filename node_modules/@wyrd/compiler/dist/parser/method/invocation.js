"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var receiver_as_value_1 = require("./receiver-as-value");
var receiver_as_type_1 = require("./receiver-as-type");
var utils_1 = require("../utils");
var error_1 = require("../error");
function parseMethodInvokeExpr(tt, parseExpr, scope, prevExpr) {
    tt.next(); // Skip the `dot` token
    var name = tt.value;
    error_1.ParserErrorIf(tt.isNot('ident'), "Expect method invoke with token of type `identifier`, got token of type `" + tt.type + "`");
    var result;
    if (prevExpr.type === 'TypeLiteral')
        result = receiver_as_type_1.parseReceiverAsType(tt, parseExpr, scope, prevExpr);
    else
        result = receiver_as_value_1.parseReceiverAsValue(tt, parseExpr, scope, prevExpr);
    var receiverType = result.receiver.return;
    if (!scope.hasMethod(receiverType, name))
        error_1.ParserError("Invoking an undeclared method `" + receiverType + "." + name + "`");
    var parameter = utils_1.Parameter.from(result.params.map(function (expr) { return expr.return; }));
    var methodPattern = scope.getMethodPattern(receiverType, name, parameter);
    if (methodPattern === undefined)
        error_1.ParserError("Method for " + receiverType + "." + name + " with input pattern `" + parameter + "` doesn't exist");
    result.isNotBuiltin = methodPattern.isNotBuiltin;
    result.name = result.isNotBuiltin ? receiverType.type + "_" + methodPattern.name : methodPattern.name;
    var returnType = methodPattern.returnDataType;
    if (returnType.hasTypeParameters()) {
        result.return = returnType.applyTypeParametersFrom(receiverType);
    }
    else if (returnType.isGeneric) {
        result.return = receiverType.typeParameterMap[returnType.type];
    }
    else {
        result.return = returnType;
    }
    return result;
}
exports.parseMethodInvokeExpr = parseMethodInvokeExpr;
