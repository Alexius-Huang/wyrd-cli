"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("../utils");
var error_1 = require("../error");
var parameters_1 = require("../function/parameters");
var constants_1 = require("../constants");
/**
 *  Invoke method via type, for instance: Num.toStr(123)
 *  is equivalent to: 123.toStr()
 */
function parseReceiverAsType(tt, parseExpr, scope, prevExpr) {
    var result = {
        type: 'MethodInvokeExpr',
        name: 'UNDECIDED',
        receiver: constants_1.EmptyExpression,
        params: [],
        return: utils_1.DataType.Invalid,
    };
    var receiverType = prevExpr.typeObject;
    var methodName = receiverType + "." + tt.value;
    tt.next(); // Skip the name of the method
    error_1.ParserErrorIf(tt.isNot('lparen'), "Expect method `" + methodName + "` invocation should follow with token `lparen`");
    tt.next(); // Skip the left parentheses
    error_1.ParserErrorIf(tt.is('comma'), "Expect next token is an expression as parameter of method `" + methodName + "`, instead got `comma`");
    if (tt.isNot('rparen'))
        result.params = parameters_1.parseParameters(tt, parseExpr, scope);
    error_1.ParserErrorIf(result.params.length === 0, "Expect `" + methodName + "` to have parameter as receiver of type `" + receiverType + "`");
    /* Check if receiver as parameter matches the correct type */
    result.receiver = result.params.shift();
    error_1.ParserErrorIf(result.receiver.return.isNotEqualTo(receiverType), "Expect `" + methodName + "` to have receiver of type `" + receiverType + "`, instead got `" + result.receiver.return + "`");
    return result;
}
exports.parseReceiverAsType = parseReceiverAsType;
