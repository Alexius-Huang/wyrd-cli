"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
var error_1 = require("./error");
var precedence_1 = require("./precedence");
var constants_1 = require("./constants");
function parseBinaryOpExpr(tt, parseExpr, scope, prevExpr) {
    if (prevExpr.type === 'IdentLiteral' && utils_1.DataType.isInvalid(prevExpr.return)) {
        error_1.ParserError("Using the unidentified token `" + prevExpr.value + "`");
    }
    var operator = tt.value;
    if (prevExpr.type === 'BinaryOpExpr') {
        var precedence = precedence_1.compare(prevExpr.operator, operator);
        if (precedence === -1) /* Low level */ {
            prevExpr.expr2 = parseBinaryOpExpr(tt, parseExpr, scope, prevExpr.expr2);
            return prevExpr;
        }
        /* Eq or higher level */
        var newNode = {
            type: 'BinaryOpExpr',
            operator: operator,
            expr1: prevExpr,
            expr2: constants_1.EmptyExpression,
            return: utils_1.DataType.Invalid,
        };
        tt.next();
        parseExpr(newNode, { scope: scope });
        return newNode;
    }
    if (prevExpr.type === 'NotExpr') {
        prevExpr.expr = parseBinaryOpExpr(tt, parseExpr, scope, prevExpr.expr);
        return prevExpr;
    }
    if (prevExpr.type === 'OrExpr' || prevExpr.type === 'AndExpr') {
        prevExpr.expr2 = parseBinaryOpExpr(tt, parseExpr, scope, prevExpr.expr2);
        return prevExpr;
    }
    tt.next();
    var result = {
        type: 'BinaryOpExpr',
        operator: operator,
        expr1: prevExpr,
        expr2: constants_1.EmptyExpression,
        return: utils_1.DataType.Invalid,
    };
    return parseExpr(result, { scope: scope });
}
exports.parseBinaryOpExpr = parseBinaryOpExpr;
