"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var number_1 = require("./number");
var string_1 = require("./string");
var boolean_1 = require("./boolean");
var null_1 = require("./null");
var invocation_1 = require("../method/invocation");
var error_1 = require("../error");
var primitiveMapParsingFunctions = new Map([
    ['number', number_1.parseNumberLiteral],
    ['string', string_1.parseStringLiteral],
    ['boolean', boolean_1.parseBooleanLiteral],
    ['null', null_1.parseNullLiteral],
]);
function parsePrimitive(tt, parseExpr, scope, prevExpr) {
    var func = primitiveMapParsingFunctions.get(tt.type);
    var result = func(tt, scope, prevExpr);
    /* Parse wuth method invocation if value chained directly with dot token */
    while (tt.peekIs('dot')) {
        tt.next();
        result = invocation_1.parseMethodInvokeExpr(tt, parseExpr, scope, result);
    }
    // TODO: After implement operator overloading, should also test
    //       operator mixed method invocation
    if ((prevExpr === null || prevExpr === void 0 ? void 0 : prevExpr.type) === 'BinaryOpExpr') {
        prevExpr.expr2 = result;
        var operator = prevExpr.operator;
        var opLeft = prevExpr.expr1.return;
        var opRight = result.return;
        var operatorObj = scope.getOperatorPattern(operator, opLeft, opRight);
        if (operatorObj === undefined)
            error_1.ParserError("Invalid operation for operator `" + prevExpr.operator + "` with operands of type `" + opLeft + "` and `" + opRight + "`");
        prevExpr.return = operatorObj.returnDataType;
        return prevExpr;
    }
    if ((prevExpr === null || prevExpr === void 0 ? void 0 : prevExpr.type) === 'PrioritizedExpr') {
        prevExpr.expr = result;
        prevExpr.return = result.return;
    }
    return result;
}
exports.parsePrimitive = parsePrimitive;
