"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
var identifier_1 = require("./identifier");
var primitives_1 = require("./primitives");
var type_literal_1 = require("./type-literal");
var composite_literals_1 = require("./composite-literals");
var this_literal_1 = require("./this-literal");
var declaration_1 = require("./record/declaration");
var reference_1 = require("./record/reference");
var variable_declaration_1 = require("./variable-declaration");
var function_1 = require("./function");
var conditional_1 = require("./conditional");
var assignment_1 = require("./assignment");
var logical_1 = require("./logical");
var prioritized_1 = require("./prioritized");
var operation_1 = require("./operation");
var invocation_1 = require("./method/invocation");
var pipe_operation_1 = require("./pipe-operation");
var lib_1 = require("./lib");
var error_1 = require("./error");
var import_1 = require("./import");
var constants_1 = require("./constants");
function parse(tokens, options) {
    var _a, _b, _c;
    var tt = new utils_1.TokenTracker(tokens);
    var globalAst = Array.from((_a = options.defaultAST) !== null && _a !== void 0 ? _a : []);
    var globalScope = (_b = options.defaultScope) !== null && _b !== void 0 ? _b : new utils_1.Scope();
    var isLib = (_c = options === null || options === void 0 ? void 0 : options.isLib) !== null && _c !== void 0 ? _c : false;
    function parseExpr(prevExpr, meta) {
        var _a, _b;
        var scope = (_a = meta === null || meta === void 0 ? void 0 : meta.scope) !== null && _a !== void 0 ? _a : globalScope;
        var ast = (_b = meta === null || meta === void 0 ? void 0 : meta.ast) !== null && _b !== void 0 ? _b : globalAst;
        if (tt.is('keyword')) {
            if (tt.valueIs('override')) {
                tt.next();
                if (tt.valueIs('def'))
                    if (tt.peekIs('builtin-type'))
                        return function_1.parseMethodDeclaration(tt, parseExpr, scope, { override: true });
                    else
                        return function_1.parseFunctionDeclaration(tt, parseExpr, scope, { override: true });
                error_1.ParserError('Keyword `override` should used with `def` to override an existing function declaration');
            }
            if (tt.valueIs('def')) {
                if (tt.peekIs('builtin-type'))
                    return function_1.parseMethodDeclaration(tt, parseExpr, scope);
                return function_1.parseFunctionDeclaration(tt, parseExpr, scope);
            }
            if (tt.valueIs('if'))
                return conditional_1.parseConditionalExpr(tt, parseExpr, scope);
            if (tt.valueIs('not'))
                return logical_1.parseLogicalNotExpr(tt, parseExpr);
            if (tt.valueIsOneOf('and', 'or')) {
                if ((prevExpr === null || prevExpr === void 0 ? void 0 : prevExpr.type) === 'PrioritizedExpr')
                    return logical_1.parseLogicalAndOrExpr(tt, parseExpr, prevExpr.expr);
                return logical_1.parseLogicalAndOrExpr(tt, parseExpr, ast.pop());
            }
            if (tt.valueIs('this'))
                return this_literal_1.parseThisLiteral(tt, scope, prevExpr);
            if (tt.valueIs('mutable'))
                return variable_declaration_1.parseVarDeclaration(tt, parseExpr, scope);
            if (tt.valueIs('record'))
                return declaration_1.parseRecordDeclaration(tt, parseExpr, scope);
            if (tt.valueIs('import')) {
                var _c = import_1.parseImportExpr(tt, parse, scope, options.rootDir), updatedScope = _c.scope, updatedAST = _c.ast;
                globalScope = updatedScope;
                if (!options.mainFileOnly)
                    globalAst = globalAst.concat(updatedAST);
                return constants_1.VoidExpression;
            }
            error_1.ParserError("Unhandled keyword token with value `" + tt.value + "`");
        }
        if (tt.isOneOf('number', 'string', 'boolean', 'null'))
            return primitives_1.parsePrimitive(tt, parseExpr, scope, prevExpr);
        if (tt.is('builtin-type'))
            return type_literal_1.parseTypeLiteral(tt, parseExpr, scope);
        if (tt.is('ident'))
            return identifier_1.parseIdentifier(tt, parseExpr, scope, prevExpr);
        if (tt.is('lbracket'))
            return composite_literals_1.parseListLiteral(tt, parseExpr, scope, prevExpr);
        if (tt.is('lparen'))
            return prioritized_1.parsePrioritizedExpr(tt, parseExpr, scope, prevExpr);
        if (tt.is('eq'))
            return assignment_1.parseAssignmentExpr(tt, parseExpr, scope, ast.pop());
        if (tt.is('dot'))
            return invocation_1.parseMethodInvokeExpr(tt, parseExpr, scope, ast.pop());
        if (tt.is('ref'))
            return reference_1.parseRecordReferenceExpr(tt, parseExpr, scope, ast.pop());
        if (tt.is('pipe-op'))
            return pipe_operation_1.parsePipeOperation(tt, parseExpr, scope, ast.pop());
        if (tt.is('lib-tag')) {
            if (!isLib)
                error_1.ParserError('Only library files can be parsed with token of type `lib-tag`, name your Wyrd file with extension `.lib.wyrd` to use lib tags');
            if (tt.valueIs('direct-method-mapping')) {
                globalScope = lib_1.parseLibDirectMethodMapping(tt, parseExpr, scope);
                return constants_1.VoidExpression;
            }
            error_1.ParserError("Unhandled library tag `" + tt.value + "`");
        }
        if (scope.hasOperator(tt.value)) {
            if ((prevExpr === null || prevExpr === void 0 ? void 0 : prevExpr.type) === 'PrioritizedExpr')
                return operation_1.parseBinaryOpExpr(tt, parseExpr, scope, prevExpr.expr);
            if ((prevExpr === null || prevExpr === void 0 ? void 0 : prevExpr.type) === 'ConditionalExpr') {
                var targetExpr = meta.target;
                return operation_1.parseBinaryOpExpr(tt, parseExpr, scope, prevExpr[targetExpr]);
            }
            return operation_1.parseBinaryOpExpr(tt, parseExpr, scope, ast.pop());
        }
        error_1.ParserError("Unhandled token type of `" + tt.type + "`");
    }
    while (true) {
        if (tt.isNot('newline')) {
            var expr = parseExpr();
            expr.type !== 'VoidExpr' && globalAst.push(expr);
        }
        if (!tt.hasNext())
            break;
        tt.next();
    }
    return { ast: globalAst, scope: globalScope };
}
exports.parse = parse;
