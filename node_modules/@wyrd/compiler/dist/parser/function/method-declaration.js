"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("../utils");
var arguments_1 = require("./arguments");
var block_1 = require("./block");
var error_1 = require("../error");
function parseMethodDeclaration(tt, parseExpr, scope, options) {
    tt.next(); // Skip 'def' keyword
    error_1.ParserErrorIf(tt.isNot('builtin-type'), "Expect method declaration to have token of type `type`, got: " + tt.type);
    var receiverType = new utils_1.DataType(tt.value);
    tt.next();
    if (tt.isNot('dot'))
        error_1.ParserError("Expect to have token of type `dot`, got: " + tt.type);
    tt.next();
    if (tt.isNot('ident'))
        error_1.ParserError('Method declaration should contain the name of the function');
    var name = tt.value;
    var compiledName = receiverType.type + "_" + tt.value;
    var invokeFormatName = receiverType.type + "." + tt.value;
    var result = {
        type: 'MethodDeclaration',
        receiverType: receiverType,
        name: compiledName,
        arguments: [],
        outputType: utils_1.DataType.Void,
        body: [],
        return: utils_1.DataType.Void,
    };
    tt.next(); // Skip the method name identifier
    var methodScope = scope.createChildScope(result.name);
    methodScope.createConstant('this', receiverType);
    /* Arguemnt and parameter parsing */
    if (tt.is('lparen'))
        result.arguments = arguments_1.parseFunctionArguments(tt, methodScope);
    var parameter = utils_1.Parameter.from(result.arguments.map(function (arg) { return arg.type; }));
    if (tt.isNot('colon'))
        error_1.ParserError("Expect token of type `colon` before the output type of the function declaration: `" + result.name + "`");
    tt.next();
    if (tt.isNot('builtin-type'))
        error_1.ParserError("Expect an output data-type of the function declaration `" + result.name + "`");
    result.outputType = new utils_1.DataType(tt.value);
    /* TODO: Check if method is redeclared with same input pattern */
    if (scope.hasMethod(receiverType, name)) {
        var methodObj = scope.getMethod(receiverType, name);
        var methodPattern = methodObj.getPatternInfo(receiverType, parameter);
        if (options === null || options === void 0 ? void 0 : options.override) {
            if (methodPattern === undefined)
                error_1.ParserError("method `" + invokeFormatName + "` need not to be override since no input pattern `" + parameter + "` declared");
            methodPattern.override();
            result.name = receiverType + "_" + methodPattern.name;
        }
        else {
            /* Check if redeclaration */
            if (methodPattern !== undefined)
                error_1.ParserError("Overriding method `" + invokeFormatName + "` with existing input pattern `" + parameter + "`; to override the method, address it with `override` keyword before `def` token");
            /* Nethod Overload */
            var overloadedPattern = methodObj.createNewPattern(parameter, result.outputType);
            result.name = receiverType + "_" + overloadedPattern.name;
        }
    }
    /* Setup a new available pattern for method invocation */
    else {
        error_1.ParserErrorIf((options === null || options === void 0 ? void 0 : options.override) === true, "Method `" + invokeFormatName + "` need not to be override since no input pattern `" + parameter + "` declared");
        var methodObj = scope.createMethod(receiverType, name);
        methodObj.createNewPattern(parameter, result.outputType);
    }
    /* Parsing the function declartion expression */
    tt.next();
    var isArrow = tt.is('arrow');
    var isDoBlock = tt.is('keyword') && tt.valueIs('do');
    error_1.ParserErrorIf(!(isArrow || isDoBlock), "Unhandled method declaration where token of type `" + tt.type + "` and value `" + tt.value + "`");
    /* Single-line function declaration expression */
    if (isArrow) {
        tt.next();
        error_1.ParserErrorIf(tt.is('newline'), "Expect method `" + receiverType.type + "`.`" + name + "` to contain expression that returns type `" + result.outputType + "`");
        while (tt.isNot('newline')) {
            result.body.push(parseExpr(undefined, { scope: methodScope, ast: result.body }));
            tt.next();
        }
    }
    /* Block-level function declaration expression */
    else if (isDoBlock) {
        block_1.parseBlock(tt, parseExpr, methodScope, result);
    }
    /* Check the return type matched with declared output type */
    var lastExpr = result.body[result.body.length - 1];
    error_1.ParserErrorIf(lastExpr.return.isNotEqualTo(result.outputType), "ParserError: Return type of method `" + invokeFormatName + "` should be `" + result.outputType + "`, instead got: `" + lastExpr.return + "`");
    return result;
}
exports.parseMethodDeclaration = parseMethodDeclaration;
