"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("../utils");
var arguments_1 = require("./arguments");
var block_1 = require("./block");
var error_1 = require("../error");
function parseFunctionDeclaration(tt, parseExpr, scope, options) {
    tt.next(); // Skip 'def' keyword
    if (tt.isNot('ident'))
        error_1.ParserError('Function declaration should contain the name of the function');
    var result = {
        type: 'FunctionDeclaration',
        name: tt.value,
        arguments: [],
        outputType: utils_1.DataType.Void,
        body: [],
        return: utils_1.DataType.Void,
    };
    tt.next(); // Skip the function name identifier
    var functionalScope = scope.createChildScope(result.name);
    /* Arguemnt and parameter parsing */
    if (tt.is('lparen'))
        result.arguments = arguments_1.parseFunctionArguments(tt, functionalScope);
    var parameter = utils_1.Parameter.from(result.arguments.map(function (arg) { return arg.type; }));
    if (tt.isNot('colon'))
        error_1.ParserError("Expect token of type `colon` before the output type of the function declaration: `" + result.name + "`");
    tt.next();
    if (tt.isNot('builtin-type'))
        error_1.ParserError("Expect an output data-type of the function declaration `" + result.name + "`");
    result.outputType = new utils_1.DataType(tt.value);
    /* Check if function is redeclared with same input pattern */
    if (scope.hasFunction(result.name)) {
        var functionObj = scope.getFunction(result.name);
        var functionPattern = functionObj.getPatternInfo(parameter);
        if (options === null || options === void 0 ? void 0 : options.override) {
            if (functionPattern === undefined)
                error_1.ParserError("Function `" + result.name + "` need not to be override since no input pattern `" + parameter + "` declared");
            functionPattern.override();
            result.name = functionPattern.name;
        }
        else {
            /* Check if redeclaration */
            if (functionPattern !== undefined)
                error_1.ParserError("Overriding function `" + result.name + "` with existing input pattern `" + parameter + "`; to override the function, address it with `override` keyword before `def` token");
            /* Function Overload */
            var overloadedPattern = functionObj.createNewPattern(parameter, result.outputType);
            result.name = overloadedPattern.name;
        }
    }
    /* Setup a new available pattern for function invocation */
    else {
        error_1.ParserErrorIf((options === null || options === void 0 ? void 0 : options.override) === true, "Function `" + result.name + "` need not to be override since no input pattern `" + parameter + "` declared");
        var functionObj = scope.createFunction(result.name);
        functionObj.createNewPattern(parameter, result.outputType);
    }
    /* Parsing the function declartion expression */
    tt.next();
    var isArrow = tt.is('arrow');
    var isDoBlock = tt.is('keyword') && tt.valueIs('do');
    error_1.ParserErrorIf(!(isArrow || isDoBlock), "Unhandled function declaration where token of type `" + tt.type + "` and value `" + tt.value + "`");
    /* Single-line function declaration expression */
    if (isArrow) {
        tt.next();
        error_1.ParserErrorIf(tt.is('newline'), "Expect function `" + result.name + "` to contain expression that returns type `" + result.outputType + "`");
        while (tt.isNot('newline')) {
            result.body.push(parseExpr(undefined, { scope: functionalScope, ast: result.body }));
            tt.next();
        }
    }
    /* Block-level function declaration expression */
    else if (isDoBlock) {
        block_1.parseBlock(tt, parseExpr, functionalScope, result);
    }
    /* Check the return type matched with declared output type */
    var lastExpr = result.body[result.body.length - 1];
    error_1.ParserErrorIf(lastExpr.return.isNotEqualTo(result.outputType), "ParserError: Return type of function `" + result.name + "` should be `" + result.outputType + "`, instead got: `" + lastExpr.return + "`");
    return result;
}
exports.parseFunctionDeclaration = parseFunctionDeclaration;
