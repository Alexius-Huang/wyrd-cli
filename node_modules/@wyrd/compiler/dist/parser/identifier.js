"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
var function_invocation_1 = require("./function-invocation");
var error_1 = require("./error");
var assignment_1 = require("./assignment");
var record_1 = require("./record");
var invocation_1 = require("./method/invocation");
var type_literal_1 = require("./type-literal");
function parseIdentifier(tt, parseExpr, scope, prevExpr) {
    var tokenName = tt.value;
    var result = {
        type: 'IdentLiteral',
        value: tokenName,
        return: utils_1.DataType.Invalid,
    };
    /* Handle Identifier as a Variable */
    if (scope.hasVariable(tokenName)) {
        result.return = scope.getVariable(tokenName).type;
        while (tt.peekIs('dot') || tt.peekIs('ref')) {
            tt.next();
            if (tt.is('dot')) {
                result = invocation_1.parseMethodInvokeExpr(tt, parseExpr, scope, result);
            }
            else {
                result = record_1.parseRecordReferenceExpr(tt, parseExpr, scope, result);
            }
        }
    }
    /* Handle Identifier as a Function*/
    else if (scope.hasFunction(tokenName)) {
        if (!tt.peekIs('lparen'))
            error_1.ParserError("Unhandled function `" + tokenName + "` as a value, currently Wyrd-Lang do not support function object");
        result = function_invocation_1.parseFunctionInvokeExpr(tt, parseExpr, scope, prevExpr);
        while (tt.peekIs('dot') || tt.peekIs('ref')) {
            tt.next();
            if (tt.is('dot')) {
                result = invocation_1.parseMethodInvokeExpr(tt, parseExpr, scope, result);
            }
            else {
                result = record_1.parseRecordReferenceExpr(tt, parseExpr, scope, result);
            }
        }
    }
    /* Handle Identifier as a Record */
    else if (scope.hasRecord(tokenName)) {
        result = record_1.parseRecordLiteral(tt, parseExpr, scope, prevExpr);
    }
    else if (scope.hasGenericType(tokenName)) {
        return type_literal_1.parseTypeLiteral(tt, parseExpr, scope);
    }
    else if (scope.hasGenericPlaceholder(tokenName)) {
        result.return = utils_1.DataType.Void;
        return result;
    }
    if ((prevExpr === null || prevExpr === void 0 ? void 0 : prevExpr.type) === 'BinaryOpExpr') {
        error_1.ParserErrorIf(utils_1.DataType.isInvalid(result.return), "Using the unidentified token `" + tokenName + "`");
        prevExpr.expr2 = result;
        var operator = prevExpr.operator;
        var opLeft = prevExpr.expr1.return;
        var opRight = result.return;
        var operatorObj = scope.getOperatorPattern(operator, opLeft, opRight);
        if (operatorObj === undefined)
            error_1.ParserError("Invalid operation for operator `" + prevExpr.operator + "` with operands of type `" + opLeft + "` and `" + opRight + "`");
        prevExpr.return = operatorObj.returnDataType;
        return prevExpr;
    }
    if ((prevExpr === null || prevExpr === void 0 ? void 0 : prevExpr.type) === 'PrioritizedExpr') {
        prevExpr.expr = result;
        prevExpr.return = result.return;
    }
    if (result.type === 'IdentLiteral' && result.return.isEqualTo(utils_1.DataType.Invalid)) {
        tt.next(); // Skip the current identifier
        /* Handle Assignment Expression when identifier is unknown */
        if (tt.is('eq'))
            return assignment_1.parseAssignmentExpr(tt, parseExpr, scope, result);
        error_1.ParserError("Using the unidentified token `" + result.value + "`");
    }
    return result;
}
exports.parseIdentifier = parseIdentifier;
