"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
var error_1 = require("./error");
function parseTypeLiteral(tt, parseExpr, scope) {
    var result = {
        type: 'TypeLiteral',
        value: tt.value,
        typeObject: new utils_1.DataType(tt.value),
        return: utils_1.DataType.Void,
    };
    if (scope.hasGenericType(tt.value)) {
        var gt = scope.getGenericType(tt.value);
        if (!tt.peekIs('lt'))
            error_1.ParserError("Type `" + tt.value + "` has generic type parameters " + gt.typeParameters.map(function (tp) { return "`" + tp + "`"; }));
        tt.next(); // skip `ident` token
        tt.next(); // skip `lt` token
        var tps = Array.from(gt.typeParameters);
        for (var i = 0; i < tps.length; i += 1) {
            var tp = tps[i];
            if (tt.isNotOneOf('ident', 'builtin-type'))
                error_1.ParserError("Expect type parameters in generic type `" + gt.name + "` has " + tps.length + " type parameter(s), instead got: " + i);
            if (tt.is('ident') && tp.name === tt.value) {
                tt.next(); // Skip `ident`
                if (tt.isNot('colon'))
                    error_1.ParserError("Expect to have `colon` after generic type parameter name when declaring generic type parameter, instead got token of type: `" + tt.type + "`");
                tt.next(); // Skip `colon`
                if (tt.isNot('ident'))
                    error_1.ParserError("Expect to name the generic type parameter, instead got token of type: `" + tt.type + "`");
                result.typeObject.newTypeParameter(tp.name, utils_1.DataType.Generic(tt.value));
                tt.next(); // Skip `ident`
            }
            else if (scope.hasGenericPlaceholder(tt.value)) {
                var gt_1 = scope.getGenericTypeFromPlaceholder(tt.value);
                result.typeObject.newTypeParameter(gt_1.type, gt_1);
                tt.next(); // Skip `ident`
            }
            else {
                var typeLit = parseTypeLiteral(tt, parseExpr, scope);
                result.typeObject.newTypeParameter(tp.name, typeLit.typeObject);
                tt.next(); // Skip `type`
            }
            if (tt.is('comma'))
                tt.next();
        }
        if (tt.isOneOf('builtin-type', 'ident'))
            error_1.ParserError("Expect type parameters in generic type `" + gt.name + "` has " + tps.length + " type parameter(s), instead got more than " + tps.length);
        if (tt.isNot('gt'))
            error_1.ParserError("Expect type parameters in generic type literal to end with token `gt`, instead got token of type `" + tt.type + "`");
    }
    return result;
}
exports.parseTypeLiteral = parseTypeLiteral;
;
