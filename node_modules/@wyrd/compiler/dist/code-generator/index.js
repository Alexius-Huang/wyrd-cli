"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function CodeGenerateError(msg) {
    throw new Error("Code Generation Error: " + msg);
}
function spaces(n) { return ' '.repeat(n); }
function generateCode(ast, option) {
    var _a;
    var result = '';
    var index = 0;
    var functionLayers = 0;
    var minify = (_a = option === null || option === void 0 ? void 0 : option.minify) !== null && _a !== void 0 ? _a : false;
    var commaDelimiter = minify ? ',' : ', ';
    function genExpr(expr) {
        switch (expr.type) {
            case 'NumberLiteral':
            case 'IdentLiteral':
                return { result: expr.value, type: expr.type };
            case 'StringLiteral':
                return { result: "'" + expr.value + "'", type: expr.type };
            case 'BooleanLiteral':
                return { result: expr.value === 'True' ? 'true' : 'false', type: expr.type };
            case 'NullLiteral':
                return { result: 'null', type: expr.type };
            case 'ListLiteral':
                return codeGenListLiteral(expr);
            case 'ThisLiteral':
                return { result: '_this', type: expr.type };
            case 'NotExpr':
                return codeGenNotExpr(expr);
            case 'AndExpr':
            case 'OrExpr':
                return codeGenAndOrExpr(expr);
            case 'RecordLiteral':
                return codeGenRecordLiteral(expr);
            case 'RecordReferenceExpr':
                return codeGenRecordReferenceExpr(expr);
            case 'AssignmentExpr':
                return codeGenAssignmentExpr(expr);
            case 'VarDeclaration':
                return codeGenVarDeclaration(expr);
            case 'VarAssignmentExpr':
                return codeGenVarAssignmentExpr(expr);
            case 'BinaryOpExpr':
                return codeGenBinaryOpExpr(expr);
            case 'PrioritizedExpr':
                return codeGenPrioritizedExpr(expr);
            case 'FunctionDeclaration':
                return codeGenFunctionDeclaration(expr);
            case 'FunctionInvokeExpr':
                return codeGenFunctionInvokeExpr(expr);
            case 'MethodDeclaration':
                return codeGenMethodDeclaration(expr);
            case 'MethodInvokeExpr':
                return codeGenMethodInvokeExpr(expr);
            case 'ConditionalExpr':
                return codeGenConditionalExpr(expr);
            case 'DoBlockExpr':
                return codeGenDoBlockExpr(expr);
            case 'VoidExpr':
                console.warn('Code Generation Warning: `VoidExpression` is expected to be avoid during the parsing phase');
                return { result: '', type: 'VoidExpr' };
            default:
                CodeGenerateError("Unhandled expression of type `" + (expr).type + "`");
        }
    }
    function codeGenListLiteral(expr) {
        var values = expr.values;
        return { result: "[" + values.map(function (v) { return genExpr(v).result; }).join(commaDelimiter) + "]", type: 'ListLiteral' };
    }
    var LogicalBinaryOperators = new Set(['>', '<', '>=', '<=', '==', '!=']);
    function codeGenBinaryOpExpr(expr) {
        var expr2Result = '';
        if (expr.expr2 === undefined)
            CodeGenerateError('Expect 2nd expression in binary operation');
        else if (expr.expr2.type === 'BinaryOpExpr' && !LogicalBinaryOperators.has(expr.operator)) {
            expr2Result = "(" + genExpr(expr.expr2).result + ")";
        }
        else {
            expr2Result = genExpr(expr.expr2).result;
        }
        if (expr.operator === "==" /* EqEq */ || expr.operator === "!=" /* BangEq */) {
            if (minify)
                return { result: "" + genExpr(expr.expr1).result + expr.operator + "=" + expr2Result, type: 'BinaryOpExpr' };
            return { result: genExpr(expr.expr1).result + " " + expr.operator + "= " + expr2Result, type: 'BinaryOpExpr' };
        }
        if (minify)
            return { result: "" + genExpr(expr.expr1).result + expr.operator + expr2Result, type: 'BinaryOpExpr' };
        return { result: genExpr(expr.expr1).result + " " + expr.operator + " " + expr2Result, type: 'BinaryOpExpr' };
    }
    function codeGenNotExpr(expr) {
        if (expr.expr === undefined)
            CodeGenerateError('Expect logical Not have expression');
        if (expr.expr.type === 'PrioritizedExpr')
            return { result: "!" + genExpr(expr.expr).result, type: 'NotExpr' };
        return { result: "!(" + genExpr(expr.expr).result + ")", type: 'NotExpr' };
    }
    function codeGenAndOrExpr(expr) {
        var logicType = expr.type === 'AndExpr' ? 'And' : 'Or';
        if (expr.expr2 === undefined)
            CodeGenerateError("Expect logical " + logicType + " have expression");
        var logicOperator = logicType === 'And' ? '&&' : '||';
        if (minify)
            return { result: "" + genExpr(expr.expr1).result + logicOperator + genExpr(expr.expr2).result, type: expr.type };
        return { result: genExpr(expr.expr1).result + " " + logicOperator + " " + genExpr(expr.expr2).result, type: expr.type };
    }
    function codeGenRecordLiteral(expr) {
        var properties = expr.properties;
        if (minify) {
            var recordStr_1 = properties.map(function (_a) {
                var name = _a.name, value = _a.value;
                return name + ":" + genExpr(value).result;
            }).join(',');
            return { result: "{" + recordStr_1 + "}", type: 'RecordLiteral' };
        }
        var recordStr = properties.map(function (_a) {
            var name = _a.name, value = _a.value;
            return name + ": " + genExpr(value).result;
        }).join(', ');
        return { result: "{ " + recordStr + " }", type: 'RecordLiteral' };
    }
    function codeGenRecordReferenceExpr(expr) {
        var recordExpr = expr.recordExpr, property = expr.property;
        return { result: genExpr(recordExpr).result + "." + property, type: 'RecordReferenceExpr' };
    }
    function codeGenAssignmentExpr(expr) {
        if (expr.expr2 === undefined)
            CodeGenerateError('Expect assignment to have expression to evaluate');
        if (minify)
            return { result: "const " + genExpr(expr.expr1).result + "=" + genExpr(expr.expr2).result, type: 'AssignmentExpr' };
        return { result: "const " + genExpr(expr.expr1).result + " = " + genExpr(expr.expr2).result, type: 'AssignmentExpr' };
    }
    function codeGenVarDeclaration(expr) {
        if (expr.expr2 === undefined)
            CodeGenerateError('Expect mutable variable declaration to have expression to evaluate');
        if (minify)
            return { result: "let " + expr.expr1.value + "=" + genExpr(expr.expr2).result, type: 'VarDeclaration' };
        return { result: "let " + expr.expr1.value + " = " + genExpr(expr.expr2).result, type: 'VarDeclaration' };
    }
    function codeGenVarAssignmentExpr(expr) {
        if (expr.expr2 === undefined)
            CodeGenerateError('Expect mutable variable assignment expression to have expression to evaluate');
        if (minify)
            return { result: expr.expr1.value + "=" + genExpr(expr.expr2).result, type: 'VarAssignmentExpr' };
        return { result: expr.expr1.value + " = " + genExpr(expr.expr2).result, type: 'VarAssignmentExpr' };
    }
    function codeGenPrioritizedExpr(expr) {
        if (expr.expr)
            return { result: "(" + genExpr(expr.expr).result + ")", type: 'PrioritizedExpr' };
        return { result: '()', type: 'PrioritizedExpr' };
    }
    function codeGenFunctionDeclaration(expr) {
        var name = expr.name, args = expr.arguments, body = expr.body;
        var s = spaces(functionLayers * 2);
        functionLayers++;
        if (args.length === 0) {
            if (minify)
                return { result: "function " + name + "(){" + codeGenFunctionBody(body, [], 0) + "}", type: 'FunctionDeclaration' };
            return { result: "function " + name + "() {\n" + codeGenFunctionBody(body, [], functionLayers * 2) + "\n" + s + "}", type: 'FunctionDeclaration' };
        }
        if (minify)
            return { result: "function " + name + "(" + codeGenArguments(args) + "){" + codeGenFunctionBody(body, args, 0) + "}", type: 'FunctionDeclaration' };
        return { result: "function " + name + "(" + codeGenArguments(args) + ") {\n" + codeGenFunctionBody(body, args, functionLayers * 2) + "\n" + s + "}", type: 'FunctionDeclaration' };
    }
    function codeGenArguments(args) {
        return args.map(function (_a) {
            var ident = _a.ident;
            return ident;
        }).join(commaDelimiter);
    }
    function codeGenFunctionBody(body, args, indent) {
        var i = 0;
        var result = [];
        if (minify) {
            while (i < body.length) {
                result.push(genExpr(body[i]).result + ";");
                i += 1;
            }
            var lastIndex_1 = result.length - 1;
            result[lastIndex_1] = "return " + result[lastIndex_1];
            functionLayers--;
            return result.join('');
        }
        while (i < body.length) {
            result.push("" + ' '.repeat(indent) + genExpr(body[i]).result + ";");
            i += 1;
        }
        var lastIndex = result.length - 1;
        result[lastIndex] = result[lastIndex].slice(0, indent) + "return " + result[lastIndex].slice(indent);
        functionLayers--;
        return result.join('\n');
    }
    function codeGenFunctionInvokeExpr(expr) {
        var name = expr.name, params = expr.params;
        return { result: name + "(" + params.map(function (p) { return genExpr(p).result; }).join(commaDelimiter) + ")", type: 'FunctionInvokeExpr' };
    }
    function codeGenMethodDeclaration(expr) {
        var name = expr.name, args = expr.arguments, body = expr.body;
        var s = spaces(functionLayers * 2);
        functionLayers++;
        if (args.length === 0) {
            if (minify)
                return { result: "function " + name + "(_this){" + codeGenFunctionBody(body, [], 0) + "}", type: 'MethodDeclaration' };
            return { result: "function " + name + "(_this) {\n" + codeGenFunctionBody(body, [], functionLayers * 2) + "\n" + s + "}", type: 'MethodDeclaration' };
        }
        if (minify)
            return { result: "function " + name + "(_this," + codeGenArguments(args) + "){" + codeGenFunctionBody(body, args, 0) + "}", type: 'MethodDeclaration' };
        return { result: "function " + name + "(_this, " + codeGenArguments(args) + ") {\n" + codeGenFunctionBody(body, args, functionLayers * 2) + "\n" + s + "}", type: 'MethodDeclaration' };
    }
    function codeGenMethodInvokeExpr(expr) {
        var name = expr.name, receiver = expr.receiver, params = expr.params, isNotBuiltin = expr.isNotBuiltin;
        var args = params.map(function (p) { return genExpr(p).result; }).join(commaDelimiter);
        if (isNotBuiltin) {
            if (params.length === 0)
                return { result: name + "(" + genExpr(receiver).result + ")", type: 'MethodInvokeExpr' };
            if (minify)
                return { result: name + "(" + genExpr(receiver).result + "," + args + ")", type: 'MethodInvokeExpr' };
            return { result: name + "(" + genExpr(receiver).result + ", " + args + ")", type: 'MethodInvokeExpr' };
        }
        if (receiver.type === 'MethodInvokeExpr' || receiver.type === 'FunctionInvokeExpr' || receiver.type === 'IdentLiteral')
            return { result: genExpr(receiver).result + "." + name + "(" + args + ")", type: 'MethodInvokeExpr' };
        return { result: "(" + genExpr(receiver).result + ")." + name + "(" + args + ")", type: 'MethodInvokeExpr' };
    }
    function codeGenConditionalExpr(expr) {
        var condition = expr.condition, expr1 = expr.expr1, expr2 = expr.expr2;
        var result;
        if (minify) {
            result = genExpr(condition).result + "?" + genExpr(expr1).result + ":";
        }
        else {
            result = genExpr(condition).result + " ? " + genExpr(expr1).result + " : ";
        }
        if (expr2.type === 'ConditionalExpr') {
            result += "(" + codeGenConditionalExpr(expr2).result + ")";
        }
        else if (expr2.type === 'VoidExpr') {
            result += 'null';
        }
        else {
            result += genExpr(expr2).result;
        }
        return { result: result, type: 'ConditionalExpr' };
    }
    function codeGenDoBlockExpr(expr) {
        var body = expr.body;
        if (minify)
            return { result: "(function(){" + codeGenFunctionBody(body, [], 0) + "})()", type: 'DoBlockExpr' };
        return { result: "(function () {\n" + codeGenFunctionBody(body, [], 2) + "\n})()", type: 'DoBlockExpr' };
    }
    var notRequiredSemicolonSet = new Set([
        'FunctionDeclaration',
        'MethodDeclaration'
    ]);
    if (minify) {
        while (index < ast.length) {
            var expr = ast[index];
            var generated = genExpr(expr);
            result += "" + generated.result;
            if (!notRequiredSemicolonSet.has(generated.type))
                result += ';';
            index++;
        }
    }
    else {
        while (index < ast.length) {
            var expr = ast[index];
            var generated = genExpr(expr);
            result += "" + generated.result;
            if (!notRequiredSemicolonSet.has(generated.type))
                result += ';\n';
            else
                result += '\n\n';
            index++;
        }
    }
    return result;
}
exports.generateCode = generateCode;
